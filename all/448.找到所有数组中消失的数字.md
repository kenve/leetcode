### [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

**题目：** 给定一个范围在  `1 ≤ a[i] ≤ n` (_n_=数组大小)的整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 `[1, n]` 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为 **O(n)** 的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

示例:

```
输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]
```

**题解一：两次遍历**

遍历所有元素把所有出现的位置进行**负数**标记，然后再遍历一遍数组，即可找到没有出现过的数字。题目要求不使用额外空间，所以需需改原数组。

对数组进行标记：遍历数组元素当该元素值，求其原本应该出现的位置（`pos = nums[i] - 1`)，判断该位置的元素值是否为负数（`nums[pos] < 0`），是否的话结束本轮循环，否的话把改位置的元素值更改为负数 `nums[pos] = -nums[pos]`，重复循环直至遍历完所有元素。

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDisappearedNumbers = function (nums) {
  //
  const res = [];
  for (let i = 0; i < nums.length; i++) {
    // 当前遍历到的元素的下标位置，如果 nums[i] 的值已经是负数需要取绝对值（因为可能被之前的遍历修改为负数了）
    const pos = Math.abs(nums[i]) - 1;
    // 该位置的值设置为负数（已经是负数不需要重设，说明有重复的元素或者已经设置了值）
    if (nums[pos] > 0) {
      nums[pos] = -nums[pos];
    }
  }
  // 循环查找标记，即元素值不为负数的位置的元素值（数字值）
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] > 0) {
      res.push(i + 1);
    }
  }
  return res;
};
```

复杂度分析：

- 时间复杂度：O(n)，两次遍历为 O(2n)，n 为数组长度。
- 空间复杂度：O(1)，使用的常数空间。
