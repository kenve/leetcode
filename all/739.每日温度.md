### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

**题目：** 请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用  `0` 来代替。

例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。

提示：气温列表长度的范围是 `[1, 30000]`。每个气温的值的均为华氏度，都是在  `[30, 100]`  范围内的整数。

**题解一：暴力（两层遍历）**

```js
/**
 * @param {number[]} T
 * @return {number[]}
 */
var dailyTemperatures = function (T) {
  // 实例化一个 T 数组长度的结果数组，并填充 0 元素
  const res = new Array(T.length).fill(0);
  // 遍历：第一层为当前位置温度，如果后有大于当前温度的值则该位置减去当前位置就为等待天数
  // 当前位置的温度
  for (let i = 0; i < T.length; i++) {
    // 当前位置后面的温度
    for (let j = i + 1; j < T.length; j++) {
      // 是否大于当前位置的温度的值
      if (T[i] < T[j]) {
        res[i] = j - i;
        break;
      }
    }
  }
  return res;
};
```

复杂度分析：

- 时间复杂度：O(n^2)。
- 空间复杂度：O(n)，其中 n 是数组 res 的长度。

**题解二：单调栈**

**单调栈**通过维持栈内值的单调递增(递减)性，在整体 O(n) 的时间内处理需要大小比较的问题。

维持一个单调递减的栈，表示每天的温度；为了方便计算天数差，我们这里存放位置(即日期)而非温度本身。我们从左向右遍历温度数组，对于每个日期 p，如果 p 的温度比栈 顶存储位置 q 的温度高，则我们取出 q，并记录 q 需要等待的天数为 p − q；

我们重复这一过程， 直到 p 的温度小于等于栈顶存储位置的温度(或空栈)时，我们将 p 插入栈顶，然后考虑下一天。在这个过程中，栈内数组永远保持单调递减，避免了使用排序进行比较。最后若栈内剩余一些日期，则说明它们之后都没有出现更暖和的日期。

```js
/**
 * @param {number[]} T
 * @return {number[]}
 */
var dailyTemperatures = function (T) {
  // 实例化一个 T 数组长度的结果数组，并填充 0 元素
  const res = new Array(T.length).fill(0);
  // 单调栈
  const stack = [];
  // 左到右遍历 T 数组
  for (let i = 0; i < T.length; i++) {
    // 当栈不为空时，遍历单调栈
    while (stack.length > 0) {
      // 如果栈顶温度大于等于当前温度，停止并将该温度位置入栈
      const prevIndex = stack[stack.length - 1];
      if (T[prevIndex] >= T[i]) {
        break;
      }
      // 否则当前温度大于栈顶温度，该元素出栈，并计算天数
      stack.pop();
      res[prevIndex] = i - prevIndex;
    }
    // 该温度位置入栈
    stack.push(i);
  }
  return res;
};
```

复杂度分析：

- 时间复杂度：O(n)，其中 n 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。
- 空间复杂度：O(n)，其中 n 是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。
