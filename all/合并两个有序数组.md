### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

**题目：** 给你两个有序整数数组  nums1 和 nums2，请你将 nums2 合并到  nums1  中，使 nums1 成为一个有序数组。

说明:

初始化 _nums1_ 和 _nums2_ 的元素数量分别为  *m* 和 _n_。
你可以假设 _nums1_ 有足够的空间（空间大小大于或等于 _m_ + _n_）来保存 _nums2_ 中的元素。

示例:

```
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

**题解一：数组 API**

```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function (nums1, m, nums2, n) {
  nums1.splice(m, n, ...nums2);
  nums1.sort((a, b) => a - b);
};
```

复杂度分析

时间复杂度 : O((n + m)log(n + m))。
空间复杂度 : O(1)。

**题解二：**

- `nums1` 、 `nums2` 有序，若把 `nums2` 全部合并到 `nums1`，则合并后的 `nums1` 长度为 `m+n`
- 我们可以从下标 `m+n-1` 的位置填充 `nums1`，比较 `nums1[len1]` 与 `nums2[len2]` 的大小，将最大值写入 `nums1[len]`，即
  - `nums1[len1] >= nums2[len2]`，`nums1[len--] = nums1[len1--]`，这里 `--` 是因为写入成功后，下标自动建议，继续往前比较
- 否则 `nums1[len--] = nums2[len2--]`
- 边界条件：
- 若 `len1 < 0`，即 `len2 >= 0` ，此时 `nums1` 已重写入，`nums2` 还未合并完，仅仅需要将 `nums2` 的剩余元素（0…len）写入 `nums2` 即可，写入后，合并完成
- 若 `len2 < 0`，此时 `nums2` 已全部合并到 `nums1`，合并完成

```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function (nums1, m, nums2, n) {
  let length = m + n;
  while (n > 0) {
    if (m <= 0) {
      nums1[--length] = nums2[--n];
      continue;
    }
    nums1[--length] = nums1[m - 1] >= nums2[n - 1] ? nums1[--m] : nums2[--n];
  }
};
```

**复杂度分析**
时间复杂度: O((n + m)。
空间复杂度: O(1)。
