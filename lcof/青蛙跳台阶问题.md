### [面试题 10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

同 [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

**题目：** 面试题 10- II. 青蛙跳台阶问题
一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶。求该青蛙跳上一个 `n` 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

示例 1：

```
输入：n = 2
输出：2
```

示例 2：

```
输入：n = 7
输出：21
```

提示：`0 <= n <= 100`

**题解一：斐波那契数**

在上述方法中，我们使用 `dp` 数组，其中 `dp[i]=dp[i-1]+dp[i-2]`。可以很容易通过分析得出 `dp[i]` 其实就是第 `i` 个斐波那契数。

```js
fib(n) = fib(n - 1) + fib(n - 2);
```

现在我们必须找出以 `1` 和 `2` 作为第一项和第二项的斐波那契数列中的第 `n` 个数，也就是说 `fib(1)==1` 且 `fib(2)=2`。

复杂度分析：

- 时间复杂度：O(n)。
- 空间复杂度：O(1)。

```js
/**
 * @param {number} n
 * @return {number}
 */
var numWays = function (n) {
  let a = 1,
    b = 1,
    sum;
  for (let i = 0; i < n; i++) {
    sum = (a + b) % 1000000007;
    a = b;
    b = sum;
  }
  return a;
};
```

**题解二：动态规划**

不难发现，这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建，我们可以使用动态规划来解决这一问题。

第 `i` 阶可以由以下两种方法得到：

1. 在第 `(i-1)` 阶后向上爬 `1` 阶。
2. 在第 `(i-2)` 阶后向上爬 `2` 阶。

所以到达第 `i` 阶的方法总数就是到第 `(i−1)` 阶和第 `(i−2)` 阶的方法数之和。

令 `dp[i]` 表示能到达第 `i` 阶的方法总数为

```js
dp[i]=dp[i−1]+dp[i−2]
```

```js
/**
 * @param {number} n
 * @return {number}
 */
var numWays = function (n) {
  const dp = [];
  dp[0] = 1;
  dp[1] = 1;
  for (let i = 2; i <= n; i++) {
    dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
  }
  return dp[n];
};
```

复杂度分析：

- 时间复杂度：O(n)。
- 空间复杂度：O(n)。
