### [剑指 Offer 15. 二进制中 1 的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

同 [191. 位 1 的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

**题目：** 请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9  表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

示例 1：

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

示例 2：

```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

示例 3：

```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

**题解一：正则**

```js
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function (n) {
  // 将二进制转为字符串，会去掉前面无用的 0
  let str = n.toString(2);
  // 匹配出所有的 1（也可以遍历字符串统计所有 1）
  let arr = str.match(/1/g);
  // arr 是否为 null 为空返回 0，否则返回所有 1 数组的长度
  return arr ? arr.length : 0;
};
```

复杂度分析：

- 时间复杂度：O(1)
- 空间复杂度：O(1)

**题解二：循环和位移动**

直接遍历数字的 32 位。如果某一位是 1，将计数器加一。

使用 _位掩码_ 来检查数字的第 i<sup>th</sup> 位。一开始，掩码 m=1 因为 1 的二进制表示是：

**0000 0000 0000 0000 0000 0000 0000 0001**

显然，任何数字跟掩码 1 进行逻辑与运算，都可以让我们获得这个数字的最低位。检查下一位时，我们将掩码左移一位：

**0000 0000 0000 0000 0000 0000 0000 0010**

并重复此过程。

```js
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function (n) {
  let count = 0;
  let mask = 1;
  for (let i = 0; i < 32; i++) {
    if ((n & mask) != 0) {
      count++;
    }
    mask <<= 1;
  }
  return count;
};
```

复杂度分析：

- 时间复杂度：O(1)。运行时间依赖于数字 n 的位数。由于这题中 n 是一个 32 位数，所以运行时间是 O(1) 的。

- 空间复杂度：O(1)。没有使用额外空间。

**题解三：位运算操作技巧**

对前面的算法进行优化。不再检查数字的每一个位，而是不断把数字最后一个 1 反转，并把答案加一。当数字变成 0 的时候偶，我们就知道它没有 1 的位了，此时返回答案。
关键的想法是对于任意数字 nn ，将 nn 和 n - 1n−1 做与运算，会把最后一个 11 的位变成 0 。为什么？考虑 n 和 n−1 的二进制表示。

![将 n 和 n−1 做与运算会将最低位的 1 变成 0](https://pic.leetcode-cn.com/abfd6109e7482d70d20cb8fc1d632f90eacf1b5e89dfecb2e523da1bcb562f66-image.png)

在二进制表示中，数字 n 中最低位的 1 总是对应 n−1 中的 0 。因此，将 n 和 n - 1 与运算总是能把 n 中最低位的 1 变成 0 ，并保持其他位不变。

```js
/**
 * @param {number} n - a positive integer
 * @return {number}
 */
var hammingWeight = function (n) {
  let sum = 0;
  while (n != 0) {
    n = n & (n - 1);
    sum++;
  }
  return sum;
};
```

复杂度分析：

- 时间复杂度：O(1)
- 空间复杂度：O(1)
